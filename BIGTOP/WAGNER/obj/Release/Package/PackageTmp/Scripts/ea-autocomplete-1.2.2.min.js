/*! Copyright (c) 2011-2013 EasyAsk LLC. All Rights Reserved...
* Use, reproduction, transfer, publication or disclosure is prohibited
* except in accordance with the License Agreement.
*/
(function (jQuery) {
    (function ($, undefined) {

        EAAutoComplete = function () {
            return {
                defaults: {
                    dict: null,
                    submitFctn: function () { },
                    id: 'question',
                    sort: 'weight',
                    reduce: 'cluster',
                    matchAllSearchWords: true,
                    matchAnySuggestionWord: true,
                    delay: 300,
                    minLength: 2,
                    prompt: null,
                    handler: null,
                    serverSearch: '',
                    urlSearch: '/EasyAsk/apps/Advisor.jsp?indexed=1&oneshot=1&ie=UTF-8&disp=json&RequestAction=advisor&RequestData=CA_Search&CatPath=All Products&defarrangeby=////NONE////',
                    server: '',
                    url: '/EasyAsk/AutoComplete-1.2.1.jsp',
                    xOffset: 0,
                    yOffset: 0,
                    widthOffset: 0,
                    search: {
                        heading: {
                            display: true,
                            format: '<span class="ea-sug-sec-head-title">Search Suggestions for:&nbsp;</span><span class="ea-sug-sec-head-value">{value}</span>'
                        },
                        size: 5
                    }
                },
                defaultProducts: {
                    products: {
                        size: 5,
                        value: function (item, field) { return item[field]; },
                        fields: {
                            thumbnail: 'thumbnail',
                            name: 'name',
                            link: 'link',
                            description: 'description',
                            price: 'price'
                        },
                        heading: {
                            display: true,
                            format: '<span class="ea-sug-sec-head-title">Products</span><span class="ea-sug-sec-head-count">total:&nbsp;{count}</span>'
                        },

                        sizes: {
                            name: 45,
                            description: 100
                        }
                    },
                    navigation: {
                        size: 2,
                        heading: {
                            display: true,
                            format: '<span class="ea-sug-sec-head-title">{title}</span><span class="ea-sug-sec-head-count">total:&nbsp;{count}</span>'
                        },
                        sections: [{
                            type: 'category',
                            size: 5,
                            title: 'Category'
                        }]
                    }
                },
                init: function (opts, dct) {
                    var options = $.extend(true, this.defaults, {
                        dict: dct,
                        position: {
                            collision: "none",
                            my: (opts.horizAlign || "right") + " top",
                            at: (opts.horizAlign || "right") + " bottom"
                        }
                    }, opts.products ? $.extend(true, {}, this.defaultProducts, opts) : opts);
                    if (options.dict) {
                        if (options.xOffset || options.yOffset) {
                            options.position.offset = options.xOffset + " " + options.yOffset;
                        }
                        this._init(options);
                    }
                    return this;
                },
                _init: function (opts) {
                    var options = $.extend({}, opts, {
                        source: function (request, response) {
                            this.lastSearch = null;
                            var self = this;
                            $.ajax({
                                url: self.options.server + self.options.url,
                                dataType: "jsonp",
                                data: {
                                    dct: self.options.dict,
                                    num: self.options.search.size,
                                    key: request.term
                                },
                                success: function (data) {
                                    if (data.suggests) {
                                        if (data.input == self._value()) {
                                            if (self.options.handler) {
                                                self.options.handler(data.input, data.suggests);
                                            }
                                            else {
                                                response($.map(data.suggests, function (item, _idx) {
                                                    return {
                                                        label: item.val,
                                                        value: item.val,
                                                        start: item.start,
                                                        end: item.end
                                                    }
                                                }));
                                            }
                                            if (data.suggests && 0 < data.suggests.length) {
                                                // add a spacer for options (rounded corners);
                                                self.menu.element.find('li :last').after($('<div class="ea-sug-last-spacer"></div>'));
                                                self.newSearch = true;
                                                self.findProducts(data.suggests[0].val, true);
                                                self.showSuggestions();
                                            }
                                        }
                                    }
                                    else {
                                        self.disable();
                                    }
                                }
                            });
                        },

                        select: function (event, ui) {
                            var widget = $(this).data("autocomplete");
                            setTimeout(function () {
                                widget.term = '';
                                widget.options.submitFctn();
                            }, 10);  // let the select complete then process it
                        },

                        create: function (evt, ui) {
                            var widget = $(this).data("autocomplete");
                            widget._on({
                                keydown: function (event) {
                                    var keyCode = $.ui.keyCode;
                                    if (keyCode.ENTER == event.keyCode || keyCode.NUMPAD_ENTER == event.keyCode) {
                                        clearTimeout(widget.searching);
                                        if (!widget.menu.active && widget.menu.element.is(':visible')) {
                                            setTimeout(function () { widget.close(event); }, 10);
                                        }
                                    }
                                }
                            });
                        },
                        open: function () {
                            var widget = $(this).data("autocomplete");
                            widget.openCnt++;
                            this.currentWidth = undefined;
                            if (widget.wrapperId) {
                                $(widget.wrapperId).show();
                            }

                        },

                        close: function (event, ui) {
                            var widget = $(this).data("autocomplete");
                            widget.openCnt = 0;
                            this.currentWidth = undefined;
                            widget.term = '';  // clear copy since using ajax
                            $(widget.wrapperId).hide();
                        },

                        focus: function (event, ui) {
                            if (ui.item && (event.keyCode || $(this).data("autocomplete").options.hover)) { // only on keyboard unless hover
                                $(this).data("autocomplete").findProducts(ui.item.label, false);
                            }
                        }
                    });
                    this._widget = $('#' + options.id).autocomplete(options).data("autocomplete");
                    // emulate placeholder support if prompt is specified
                    if (options.prompt) {
                        var supportsPlaceholder = ('placeholder' in document.createElement('input'));
                        if (supportsPlaceholder) {
                            $('#' + options.id).attr('placeholder', options.prompt);
                        }
                        else {
                            $('#' + options.id).each(function () {
                                var placeholder = options.prompt;
                                if ($(this).val() === '') {
                                    $(this).val(placeholder).addClass('ea-sug-placeholder');
                                }
                                $(this).bind('focus', function () {
                                    if ($(this).val() === placeholder) {
                                        $(this).val('').removeClass('ea-sug-placeholder');
                                    }
                                })
							.bind('blur', function () {
							    if ($(this).val() === '' && $(this).val() !== placeholder) {
							        $(this).val(placeholder).addClass('ea-sug-placeholder');
							    }
							});
                            });
                        }
                    }
                },
                disable: function () {
                    this._widget.cancelSearch = true;
                }
            };
        };

        $(function () {
            var acprototype = $.ui.autocomplete.prototype;
            var ac_renderMenu = acprototype._renderMenu;
            var ac_create = acprototype._create;
            $.extend(acprototype, {
                openCnt: 0,
                // overrides
                _create: function () {
                    ac_create.call(this);
                    this.element.attr("spellcheck", "false");
                    var menu = this.menu.element;
                    var zindex = parseInt(menu.css('z-index')) || 100;
                    var widget = this;
                    var divWrapper = $('<div class="ea-sug-wrapper" ></div>')
				.on(
						'mousedown', function (event) {
						    event.preventDefault();
						    widget.cancelBlur = true;
						    widget._delay(function () {
						        delete widget.cancelBlur;
						    });
						})
						.zIndex(zindex)
						.width('0px')
						.css('display', 'none')
                        .css('clear', 'both')
						.uniqueId().appendTo('body');
                    this.wrapperId = '#' + divWrapper.attr('id');
                    var divLeftCol = $('<div class="ea-sug-nav ea-sug-nav-left" style="float:left;display:none;z-index:' + (zindex + 1) + '"></div>')
				.uniqueId().appendTo(divWrapper);
                    this.leftColId = '#' + divLeftCol.attr('id');
                    var divMenu = $('<div class="ea-sug-section"></div>').uniqueId().appendTo(divLeftCol);
                    this.menuId = '#' + divMenu.attr('id');
                    if (this.options.search && this.options.search.heading.display) {
                        $('<div class="ea-sug-sec-heading ea-sug-sug">' + this.generateHeading(this.options.search.heading.format, null, '&nbsp;', null) + '</div>').appendTo(divMenu);
                    }
                    menu.zIndex((zindex + 1).toString());
                    menu.removeClass('ui-corner-all ui-autocomplete').detach().appendTo(divMenu);
                    this.rightColId = '#' + $('<div class="ea-sug-nav ea-sug-nav-right" style="float:left;display:none;z-index:' + (zindex + 1) + '"></div>')
				.uniqueId().appendTo(divWrapper).attr('id');
                    this.spacerId = '#' + $('<div class="ea-sug-spacer" style="height:0px;clear:both;"></div>').uniqueId().appendTo(divWrapper).attr('id');
                    this.txtNode = $('<span style="display:none;"></span>');
                },
                _renderItem: function (ul, item) {
                    return $('<li class="ui-menu-item" style="width:auto;"></li>')
				.append($('<a class="ui-corner-all"></a>').data('ui-autocomplete-item', item)
						.append($('<div></div>').css('whiteSpace', 'nowrap')
								.append($('<span class="ea-sug-text">' + item.label.substring(0, item.start) +
										'</span><span class="ea-sug-match">' + item.label.substring(item.start, item.end) +
										'</span><span class="ea-sug-text">' + item.label.substring(item.end) + '</span>'))))
										.appendTo(ul);
                },
                _renderMenu: function (ul, items) {
                    $(this.menuId + ' .ea-sug-sec-head-value').text('"' + this.term + '"');
                    ac_renderMenu.call(this, ul, items);
                    ul.addClass('ea-sug-menu').removeClass('ui-widget-content');
                },
                _resizeMenu: function () {
                    var ul = this.menu.element;
                    if (ul.is(':hidden')) {
                        ul.outerWidth(Math.max(
                        // Firefox wraps long text (possibly a rounding bug)
                        // so we add 1px to avoid the wrapping (#7513)
							ul.width("").outerWidth() + 1,
							this.options.fixedWidth || this.element.outerWidth()
					));
                    }
                },
                _suggest: function (items) {
                    var ul = this.menu.element
				.empty()
				.zIndex(this.element.zIndex() + 1);
                    this._renderMenu(ul, items);
                    this.menu.refresh();

                    // size and position menu
                    var wasHidden = ul.is(':hidden');
                    ul.show();
                    this._resizeMenu();
                    if (wasHidden) {
                        ul.position($.extend({
                            of: this.element
                        }, this.options.position));
                    }
                    if (this.options.autoFocus) {
                        this.menu.next();
                    }
                },

                // extensions
                trimString: function (val, len) {
                    if (val) {
                        if (val.length < len) {
                            return val;
                        }
                        else {
                            var sub = val.substring(0, len);
                            var idx = sub.lastIndexOf(' ');
                            if (-1 < idx) {
                                sub = sub.substring(0, idx);
                            }
                            sub += '...';
                            return sub;
                        }
                    }
                    return val;
                },

                setColWidth: function (elt, width) {
                    elt.outerWidth(width);
                    var inner = elt.width();
                    elt.children('.ea-sug-section').each(function () { $(this).outerWidth(inner) });
                },

                showSuggestions: function () {
                    if (this.newSearch && this.openCnt < 2) {
                        this.newSearch = false;
                        var width = this.menu.element.outerWidth(true);
                        var inner = $(this.wrapperId).outerWidth(width)
					.show()
					.position($.extend({
					    of: this.element
					}, this.options.position))
					.width();
                        $(this.leftColId).show();
                        this.setColWidth($(this.leftColId), inner);
                        $(this.menuId).css('position', 'static');
                        this.menu.element.css({ 'position': 'relative', 'float': '', 'width': '', 'top': '0px', 'left': '0px' });
                        this.currentWidth = this.originalWidth = inner;
                    }
                },

                addSearch: function (data, srch) {
                    if (data && 0 == data.returnCode && data.source && data.source.products && data.source.products.items) {
                        var htmlProd = this.generateProducts(data, this.options.products.heading);
                        var htmlNav = this.generateNavigation(data);
                        if (htmlNav) { // 2 col
                            $(this.rightColId).addClass('ea-sug-multi-column');
                        }
                        var inner = this.originalWidth;
                        var menuDiv = $(this.menuId);
                        var widthLeft = htmlNav ? ((inner / 2 + .5) | 0) : inner; // default 50%
                        if (htmlNav) {
                            var splitPos = this.options.leftWidth;
                            if (splitPos) {
                                // already a number (default in px)
                                if (!isNaN(splitPos) && 0 < splitPos && splitPos < inner) {
                                    widthLeft = splitPos | 0;
                                }
                                else {
                                    var val = parseFloat(splitPos);
                                    if (!isNaN(val)) {
                                        if (splitPos.charAt(splitPos.length - 1) == '%' && 0.0 < val && val < 100.0) {
                                            widthLeft = (inner * val / 100.0 + .5) | 0;
                                        }
                                        else if (splitPos.toLowerCase().substring(splitPos.length - 2) == 'px' && 0.0 < val && val < inner) {
                                            widthLeft = val | 0;
                                        }
                                    }
                                }
                            }
                        }
                        if (htmlNav) {
                            $(this.rightColId).show();
                            this.currentWidth = widthLeft;
                        }
                        else {
                            widthLeft = this.originalWidth;
                            $(this.rightColId).hide();
                        }
                        $(this.spacerId).width(inner);
                        if (htmlProd) {
                            var cnt = data.source.products.itemDescription.totalItems;
                            if (this.prodId) {
                                $(this.prodId).remove();
                            }
                            var divProd = $('<div class="ea-sug-section ea-sug-prod ea-sug-section-vertical-space"></div>').uniqueId();
                            this.prodId = '#' + divProd.attr('id');
                            divProd.appendTo($(this.leftColId)).show();
                        }
                        else if (this.prodId) {
                            $(this.prodId).hide();
                        }
                        this.setColWidth($(this.leftColId), widthLeft);
                        var widthRight = inner - widthLeft - 2; // 2 for borders on nav
                        if (htmlProd) {
                            this.setColWidth($(this.rightColId), widthRight);
                        }
                        this.renderNavigation(htmlNav);
                        this.renderProducts(htmlProd);
                    }
                    else {
                        // no products -> no html, widen to original
                        $(this.rightColId).hide();
                        $(this.prodId).hide();
                        this.setColWidth($(this.leftColId), this.originalWidth);
                    }
                },

                generateHeading: function (format, title, value, cnt) {
                    var html = '';
                    if (format) {
                        var html = format;
                        var idx;
                        if (title) {
                            idx = html.indexOf('{title}');
                            if (-1 < idx) {
                                html = html.substring(0, idx) + title + html.substring(idx + '{title}'.length);
                            }
                        }
                        if (value) {
                            idx = html.indexOf('{value}');
                            if (-1 < idx) {
                                html = html.substring(0, idx) + value + html.substring(idx + '{value}'.length);
                            }
                        }
                        if (cnt) {
                            var idx = html.indexOf('{count}');
                            if (-1 < idx) {
                                html = html.substring(0, idx) + cnt + html.substring(idx + '{count}'.length);
                            }
                        }
                    }
                    return html;
                },

                generateCategory: function (cat, pathStart) {
                    return '<li class="ea-sug-nav-value">' +
				'<a class="ea-sug-nav-link" ref="' + cat.ids + '" ea_link="' + this.htmlEncode(pathStart + cat.nodeString) + '" href="#">' + cat.name + '</a>' + (0 < cat.productCount ? ('<span class="ea-sug-nav-count">&nbsp;(' + cat.productCount + ')</span>') : '') + '</li>';
                },
                generateCategories: function (size, title, lstCats, pathStart, format) {
                    if (lstCats && 0 < lstCats.length) {
                        var lst = '<div class="ea-sug-sec-heading">' + this.generateHeading(format, title, null, lstCats.length) + '</div><ul class="ea-sug-choices">';
                        for (var i = 0; i < size && i < lstCats.length; i++) {
                            lst += this.generateCategory(lstCats[i], pathStart);
                        }
                        lst += '</ul>';
                        return lst;
                    }
                },


                generateAttribute: function (av, pathStart) {
                    return '<li class="ea-sug-nav-value">' +
				'<a class="ea-sug-nav-link" ea_link="' + this.htmlEncode(pathStart + av.nodeString) + '" href="#">' + av.attributeValue + '</a>' + (0 < av.productCount ? ('<span class="ea-sug-nav-count">&nbsp;(' + av.productCount + ')</span>') : '') + '</li>';
                },

                generateAttributes: function (size, title, attr, pathStart, format, full) {
                    if (attr) {
                        // use full or initial, if initial and none, then use full
                        var valList = full ? attr.attributeValueList : (attr.initialAttributeValueList || attr.attributeValueList);
                        if (valList && 0 < valList.length) {
                            var lst = '<div class="ea-sug-sec-heading">' + this.generateHeading(format, title, null, valList.length) + '</div><ul class="ea-sug-choices">';
                            for (var i = 0; i < size && i < valList.length; i++) {
                                lst += this.generateAttribute(valList[i], pathStart);
                            }
                            lst += '</ul>';
                            return lst;
                        }
                    }
                },

                getCategories: function (ds, full) {
                    // use full or initial list, if initial and none then use full
                    return ds.categories ? (full ? ds.categories.categoryList : (ds.categories.initialCategoryList || ds.categories.categoryList)) : null;
                },

                getAttributes: function (ds, name) {
                    if (ds.attributes) {
                        var lcName = name.toLowerCase();
                        for (var i = 0; i < ds.attributes.attribute.length; i++) {
                            var attr = ds.attributes.attribute[i];
                            if (attr.name.toLowerCase() == lcName) {
                                return attr;
                            }
                        }
                    }
                    return null;
                },

                SEARCH_NODE: 3,

                getSearch: function (ds) {
                    var npl = ds.navPath.navPathNodeList;
                    if (npl && 0 < npl.length) {
                        var node = npl[npl.length - 1];
                        if (node.navNodePathType == this.SEARCH_NODE) {
                            return node.seoPath + '/';
                        }
                    }
                    return "";
                },
                textOnly: function (val) {
                    if (val) {
                        try {
                            return this.txtNode.html(val).text();
                        }
                        catch (err) { }
                    }
                    return val;
                },
                generateProduct: function (item) {
                    var fields = this.options.products.fields;
                    var sizes = this.options.products.sizes;
                    var value = this.options.products.value;
                    var link = value(item, fields.link);
                    var thumbnail = value(item, fields.thumbnail);
                    var name = this.trimString(this.textOnly(value(item, fields.name)), sizes.name);
                    var price = this.textOnly(value(item, fields.price));
                    var description = this.trimString(this.textOnly(value(item, fields.description)), sizes.description);
                    return '<tr class="ea-sug-product">' +
				'<td class="ea-sug-product-picture">' +
				(link ? '<a class="ea-sug-product-picture-link" href="' + (link || '#') + '">' : '') +
				(thumbnail ? '<image class="ea-sug-product-image"  src="' + thumbnail + '">' : '') +
				(link ? '</a>' : '') +
				'</td>' +
				'<td class="ea-sug-product-info">' +
				(link ? '<a class="ea-sug-product-info-link" href="' + (link || '#') + '">' : '') +
				(name ? '<div class="ea-sug-product-name">' + name + '</div>' : '') +
				(description ? '<div class="ea-sug-product-desc">' + description + '</div>' : '') +
				(price ? '<div class="ea-sug-product-price">' + price + '</div>' : '') +
				(link ? '</a>' : '') +
				'</td>' +
				'</tr>';
                },

                generateProducts: function (data, heading) {
                    var ds = data && 0 == data.returnCode ? data.source : null;
                    if (ds && ds.products && ds.products.items) {
                        var cnt = ds.products.itemDescription.totalItems;
                        var html = '';
                        if (heading && heading.display) {
                            html = '<div class="ea-sug-sec-heading">' + this.generateHeading(heading.format, null, null, cnt) + '</div>';
                        }
                        html += '<table class="ea-sug-products" border="0" style="width:100%"><tbody>';
                        var self = this;
                        $.map(data.source.products.items, function (item, _idx) {
                            html += self.generateProduct(item);
                        });
                        html += '</tbody></table>';
                        return html;
                    }
                    return null;
                },

                //			defaultSectionHeaderFormat: '<span class="ea-sug-sec-head-title">{title}</span><span class="ea-sug-sec-head-count">{count}</span>',

                generateNavigation: function (data) {
                    var ds = data && 0 == data.returnCode ? data.source : null;
                    if (ds) {
                        var navOpts = this.options.navigation.sections || [];
                        var html = '';
                        var navGenerated = 0;
                        var pathStart = this.getSearch(ds);
                        var maxSections = this.options.navigation.size || 2;
                        for (var i = 0; i < navOpts.length && navGenerated < maxSections; i++) {
                            var classType = '';
                            var itemHtml = null;
                            var navOpt = navOpts[i];
                            var format = null;
                            if (navOpts.heading) {
                                if (navOpts.heading.display) {
                                    format = navOpts.heading.format || this.options.navigation.heading.display;
                                }
                            }
                            else if (this.options.navigation.heading.display) {
                                format = this.options.navigation.heading.format;
                            }
                            if (navOpt.type.toLowerCase() == 'category') {
                                itemHtml = this.generateCategories(navOpt.size, navOpt.title || 'Category', this.getCategories(ds, navOpt.full), pathStart, format);
                                classType = ' ea-sug-cat';
                            }
                            else {
                                itemHtml = this.generateAttributes(navOpt.size, navOpt.title, this.getAttributes(ds, navOpt.type), pathStart, format, navOpt.full);
                                classType = ' ea-sug-attr';
                            }
                            if (itemHtml) {
                                var extraClass = 0 == navGenerated++ ? '' : ' ea-sug-section-vertical-space';
                                html += ('<div class="ea-sug-section' + classType + extraClass + '">' + itemHtml + '</div>');
                            }
                        }
                        if (html) {
                            html += ('<div class="ea-sug-section-vertical-space" style="clear:both;height:30px"></div>');
                            html += ('<div class="ea-sug-nav-tm">&nbsp;</div>');
                        }
                        return html;
                    }
                    return null;
                },

                renderProducts: function (html) {
                    $(this.prodId).html(html).show();
                    $('.ea-sug-product').each(function () {
                        $(this).hover(function () {
                            $(this).find('.ea-sug-product-name').toggleClass('ui-state-hover');
                        });
                    });
                    $('.ea-sug-product :not(:last)').find('.ea-sug-product-info').addClass('ea-sug-product-separator');
                    $('.ea-sug-product-name').addClass('ui-corner-all');
                },

                renderNavigation: function (html) {
                    if (html) {
                        var nav = $(this.rightColId);
                        nav.empty().append($(html));
                        nav.find('.ea-sug-section').find('li :last').after($('<div class="ea-sug-last-spacer"></div>')) // last entries in each section need padding
                        nav.show();
                        var widget = this

                        $(".ea-sug-cat a.ea-sug-nav-link").each(function () { // Category
                            var link = $(this);
                            link.unbind('click').click(function (event) {
                                widget.close();
                                //widget.options.submitFctn('nav', this.innerText+'/'+$(link).attr('ref'));
                                widget.options.submitFctn('nav_cat', $(link).attr('ea_link') + '/' + $(link).attr('ref'));
                                event.stopImmediatePropagation();
                            });
                        });
                        $(".ea-sug-attr a.ea-sug-nav-link").each(function () { // Attributes
                            var link = $(this);
                            link.unbind('click').click(function (event) {
                                widget.close(); //GGG
                                //widget.options.submitFctn('nav', this.innerText+'/'+$(link).attr('ref'));
                                widget.options.submitFctn('nav', $(link).attr('ea_link'));
                                event.stopImmediatePropagation();
                            });
                        });
                        //$('a.ea-sug-nav-link').each(function(){
                        //
                        //	var link = $(this);
                        //	link.unbind('click').click(function(event){
                        //		widget.close();//GGG
                        //		//widget.options.submitFctn('nav', this.innerText+'/'+$(link).attr('ref'));
                        //		widget.options.submitFctn('nav', $(link).attr('ea_link'));
                        //		event.stopImmediatePropagation();
                        //	});
                        //});
                        $('.ea-sug-nav-value').each(function () {
                            $(this).addClass('ui-corner-all')
						.on({
						    mouseenter: function (event) {
						        $(event.currentTarget).addClass("ui-state-hover ui-state-focus");
						    },
						    mouseleave: function (event) {
						        $(event.currentTarget).removeClass("ui-state-hover ui-state-focus");
						    },
						    click: function (event) {
						        $(event.target).closest('.ea-sug-nav-value').find('a.ea-sug-nav-link').click();
						    }
						});
                        });

                        $('.ea-sug-menu').each(function () {

                            var liitems = $('#ui-id-1').find('.ui-menu-item');
                            liitems.each(function () {
                                var link = $(this);
                                link.unbind('click').click(function (event) {
                                    widget.close();
                                    widget.options.submitFctn('nav', this.innerText);
                                    event.stopImmediatePropagation();
                                });
                            });
                        });

                    }
                    return;
                },

                findProducts: function (q, s) {
                    if (this.options.products) {
                        if (this.lastSearch == q) {
                            return;
                        }
                        this.lastSearch = q;
                        this.getProducts(q, s);
                    }
                },

                htmlEncode: function (str) {
                    return String(str)
				.replace(/&/g, '&amp;')
				.replace(/"/g, '&quot;')
				.replace(/'/g, '&#39;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;');
                },

                getProducts: function (q, s) {
                    var self = this;
                    $.ajax({
                        url: self.options.serverSearch + self.options.urlSearch + '&customer=easayt',
                        dataType: 'jsonp',
                        data: {
                            dct: this.options.dict,
                            q: q,
                            ResultsPerPage: this.options.products.size
                        },
                        success: function (prods) {
                            self.addSearch(prods, s);
                        }
                    });
                }
            });
        });


    } (jQuery));
} (window.eaj$183 || jQuery));





//jQuery UI 1.9.2. Core + autocomplete
/*! jQuery UI - v1.9.2 - 2015-11-24
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.position.js, jquery.ui.autocomplete.js, jquery.ui.menu.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function ($, undefined) {

    var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

    // prevent duplicate loading
    // this is only a problem because we proxy existing functions
    // and we don't want to double proxy them
    $.ui = $.ui || {};
    if ($.ui.version) {
        return;
    }

    $.extend($.ui, {
        version: "1.9.2",

        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });

    // plugins
    $.fn.extend({
        _focus: $.fn.focus,
        focus: function (delay, fn) {
            return typeof delay === "number" ?
			this.each(function () {
			    var elem = this;
			    setTimeout(function () {
			        $(elem).focus();
			        if (fn) {
			            fn.call(elem);
			        }
			    }, delay);
			}) :
			this._focus.apply(this, arguments);
        },

        scrollParent: function () {
            var scrollParent;
            if (($.ui.ie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
                scrollParent = this.parents().filter(function () {
                    return (/(relative|absolute|fixed)/).test($.css(this, 'position')) && (/(auto|scroll)/).test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
                }).eq(0);
            } else {
                scrollParent = this.parents().filter(function () {
                    return (/(auto|scroll)/).test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
                }).eq(0);
            }

            return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
        },

        zIndex: function (zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }

            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        },

        uniqueId: function () {
            return this.each(function () {
                if (!this.id) {
                    this.id = "ui-id-" + (++uuid);
                }
            });
        },

        removeUniqueId: function () {
            return this.each(function () {
                if (runiqueId.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });

    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
        // the element and all of its ancestors must be visible
		visible(element);
    }

    function visible(element) {
        return $.expr.filters.visible(element) &&
		!$(element).parents().andSelf().filter(function () {
		    return $.css(this, "visibility") === "hidden";
		}).length;
    }

    $.extend($.expr[":"], {
        data: $.expr.createPseudo ?
		$.expr.createPseudo(function (dataName) {
		    return function (elem) {
		        return !!$.data(elem, dataName);
		    };
		}) :
        // support: jQuery <1.8
		function (elem, i, match) {
		    return !!$.data(elem, match[3]);
		},

        focusable: function (element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },

        tabbable: function (element) {
            var tabIndex = $.attr(element, "tabindex"),
			isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });

    // support
    $(function () {
        var body = document.body,
		div = body.appendChild(div = document.createElement("div"));

        // access offsetHeight before setting the style to prevent a layout bug
        // in IE 9 which causes the element to continue to take up space even
        // after it is removed from the DOM (#8026)
        div.offsetHeight;

        $.extend(div.style, {
            minHeight: "100px",
            height: "auto",
            padding: 0,
            borderWidth: 0
        });

        $.support.minHeight = div.offsetHeight === 100;
        $.support.selectstart = "onselectstart" in div;

        // set display to none to avoid a layout bug in IE
        // http://dev.jquery.com/ticket/4014
        body.removeChild(div).style.display = "none";
    });

    // support: jQuery <1.8
    if (!$("<a>").outerWidth(1).jquery) {
        $.each(["Width", "Height"], function (i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
			type = name.toLowerCase(),
			orig = {
			    innerWidth: $.fn.innerWidth,
			    innerHeight: $.fn.innerHeight,
			    outerWidth: $.fn.outerWidth,
			    outerHeight: $.fn.outerHeight
			};

            function reduce(elem, size, border, margin) {
                $.each(side, function () {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }

            $.fn["inner" + name] = function (size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };

            $.fn["outer" + name] = function (size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }

    // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = (function (removeData) {
            return function (key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        })($.fn.removeData);
    }





    // deprecated

    (function () {
        var uaMatch = /msie ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || [];
        $.ui.ie = uaMatch.length ? true : false;
        $.ui.ie6 = parseFloat(uaMatch[1], 10) === 6;
    })();

    $.fn.extend({
        disableSelection: function () {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
			".ui-disableSelection", function (event) {
			    event.preventDefault();
			});
        },

        enableSelection: function () {
            return this.unbind(".ui-disableSelection");
        }
    });

    $.extend($.ui, {
        // $.ui.plugin is deprecated.  Use the proxy pattern instead.
        plugin: {
            add: function (module, option, set) {
                var i,
				proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([option, set[i]]);
                }
            },
            call: function (instance, name, args) {
                var i,
				set = instance.plugins[name];
                if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                    return;
                }

                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        },

        contains: $.contains,

        // only used by resizable
        hasScroll: function (el, a) {

            //If overflow is hidden, the element might have extra content, but the user wants to hide it
            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
			has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[scroll] = 1;
            has = (el[scroll] > 0);
            el[scroll] = 0;
            return has;
        },

        // these are odd functions, fix the API or move into individual plugins
        isOverAxis: function (x, reference, size) {
            //Determines when x coordinate is over "b" element axis
            return (x > reference) && (x < (reference + size));
        },
        isOver: function (y, x, top, left, height, width) {
            //Determines when x, y coordinates is over "b" element
            return $.ui.isOverAxis(y, top, height) && $.ui.isOverAxis(x, left, width);
        }
    });

})(jQuery);
(function ($, undefined) {

    var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
    $.cleanData = function (elems) {
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
            try {
                $(elem).triggerHandler("remove");
                // http://bugs.jquery.com/ticket/8235
            } catch (e) { }
        }
        _cleanData(elems);
    };

    $.widget = function (name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split(".")[0];

        name = name.split(".")[1];
        fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function (options, element) {
            // allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function (prop, value) {
            if ($.isFunction(value)) {
                prototype[prop] = (function () {
                    var _super = function () {
                        return base.prototype[prop].apply(this, arguments);
                    },
					_superApply = function (args) {
					    return base.prototype[prop].apply(this, args);
					};
                    return function () {
                        var __super = this._super,
						__superApply = this._superApply,
						returnValue;

                        this._super = _super;
                        this._superApply = _superApply;

                        returnValue = value.apply(this, arguments);

                        this._super = __super;
                        this._superApply = __superApply;

                        return returnValue;
                    };
                })();
            }
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
        }, prototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            // TODO remove widgetBaseClass, see #8155
            widgetBaseClass: fullName,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);
    };

    $.widget.extend = function (target) {
        var input = slice.call(arguments, 1),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
						$.widget.extend({}, target[key], value) :
                        // Don't extend strings, arrays, etc. with objects
						$.widget.extend({}, value);
                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = typeof options === "string",
			args = slice.call(arguments, 1),
			returnValue = this;

            // allow multiple hashes to be passed on init
            options = !isMethodCall && args.length ?
			$.widget.extend.apply(null, [options].concat(args)) :
			options;

            if (isMethodCall) {
                this.each(function () {
                    var methodValue,
					instance = $.data(this, fullName);
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack(methodValue.get()) :
						methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function () {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {})._init();
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function ( /* options, element */) { };
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.options = $.widget.extend({},
			this.options,
			this._getCreateOptions(),
			options);

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if (element !== this) {
                // 1.9 BC for #7810
                // TODO remove dual storage
                $.data(element, this.widgetName, this);
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function (event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?
                // element within the document
				element.ownerDocument :
                // element is window or document
				element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function () {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
			.unbind(this.eventNamespace)
            // 1.9 BC for #7810
            // TODO remove dual storage
			.removeData(this.widgetName)
			.removeData(this.widgetFullName)
            // support: jquery <1.6.3
            // http://bugs.jquery.com/ticket/9413
			.removeData($.camelCase(this.widgetFullName));
            this.widget()
			.unbind(this.eventNamespace)
			.removeAttr("aria-disabled")
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled");

            // clean up events and states
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,

        widget: function () {
            return this.element;
        },

        option: function (key, value) {
            var options = key,
			parts,
			curOption,
			i;

            if (arguments.length === 0) {
                // don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (value === undefined) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (value === undefined) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },
        _setOptions: function (options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },
        _setOption: function (key, value) {
            this.options[key] = value;

            if (key === "disabled") {
                this.widget()
				.toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
				.attr("aria-disabled", value);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            }

            return this;
        },

        enable: function () {
            return this._setOption("disabled", false);
        },
        disable: function () {
            return this._setOption("disabled", true);
        },

        _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement,
			instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                // accept selectors, DOM elements
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
						(instance.options.disabled === true ||
							$(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
					.apply(instance, arguments);
                }

                // copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^(\w+)\s*(.*)$/),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },

        _off: function (element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
        },

        _delay: function (handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
				.apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function (event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function (event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },

        _focusable: function (element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function (event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function (event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },

        _trigger: function (type, event, data) {
            var prop, orig,
			callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
			callback.apply(this.element[0], [event].concat(data)) === false ||
			event.isDefaultPrevented());
        }
    };

    $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
        $.Widget.prototype["_" + method] = function (element, options, callback) {
            if (typeof options === "string") {
                options = { effect: options };
            }
            var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = { duration: options };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && ($.effects.effect[effectName] || $.uiBackCompat !== false && $.effects[effectName])) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function (next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

    // DEPRECATED
    if ($.uiBackCompat !== false) {
        $.Widget.prototype._getCreateOptions = function () {
            return $.metadata && $.metadata.get(this.element[0])[this.widgetName];
        };
    }

})(jQuery);
(function ($, undefined) {

    $.ui = $.ui || {};

    var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

    function getOffsets(offsets, width, height) {
        return [
		parseInt(offsets[0], 10) * (rpercent.test(offsets[0]) ? width / 100 : 1),
		parseInt(offsets[1], 10) * (rpercent.test(offsets[1]) ? height / 100 : 1)
	];
    }
    function parseCss(element, property) {
        return parseInt($.css(element, property), 10) || 0;
    }

    $.position = {
        scrollbarWidth: function () {
            if (cachedScrollbarWidth !== undefined) {
                return cachedScrollbarWidth;
            }
            var w1, w2,
			div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
			innerDiv = div.children()[0];

            $("body").append(div);
            w1 = innerDiv.offsetWidth;
            div.css("overflow", "scroll");

            w2 = innerDiv.offsetWidth;

            if (w1 === w2) {
                w2 = div[0].clientWidth;
            }

            div.remove();

            return (cachedScrollbarWidth = w1 - w2);
        },
        getScrollInfo: function (within) {
            var overflowX = within.isWindow ? "" : within.element.css("overflow-x"),
			overflowY = within.isWindow ? "" : within.element.css("overflow-y"),
			hasOverflowX = overflowX === "scroll" ||
				(overflowX === "auto" && within.width < within.element[0].scrollWidth),
			hasOverflowY = overflowY === "scroll" ||
				(overflowY === "auto" && within.height < within.element[0].scrollHeight);
            return {
                width: hasOverflowX ? $.position.scrollbarWidth() : 0,
                height: hasOverflowY ? $.position.scrollbarWidth() : 0
            };
        },
        getWithinInfo: function (element) {
            var withinElement = $(element || window),
			isWindow = $.isWindow(withinElement[0]);
            return {
                element: withinElement,
                isWindow: isWindow,
                offset: withinElement.offset() || { left: 0, top: 0 },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),
                width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                height: isWindow ? withinElement.height() : withinElement.outerHeight()
            };
        }
    };

    $.fn.position = function (options) {
        if (!options || !options.of) {
            return _position.apply(this, arguments);
        }

        // make a copy, we don't want to modify arguments
        options = $.extend({}, options);

        var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
		target = $(options.of),
		within = $.position.getWithinInfo(options.within),
		scrollInfo = $.position.getScrollInfo(within),
		targetElem = target[0],
		collision = (options.collision || "flip").split(" "),
		offsets = {};

        if (targetElem.nodeType === 9) {
            targetWidth = target.width();
            targetHeight = target.height();
            targetOffset = { top: 0, left: 0 };
        } else if ($.isWindow(targetElem)) {
            targetWidth = target.width();
            targetHeight = target.height();
            targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
        } else if (targetElem.preventDefault) {
            // force left top to allow flipping
            options.at = "left top";
            targetWidth = targetHeight = 0;
            targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
        } else {
            targetWidth = target.outerWidth();
            targetHeight = target.outerHeight();
            targetOffset = target.offset();
        }
        // clone to reuse original targetOffset later
        basePosition = $.extend({}, targetOffset);

        // force my and at to have valid horizontal and vertical positions
        // if a value is missing or invalid, it will be converted to center
        $.each(["my", "at"], function () {
            var pos = (options[this] || "").split(" "),
			horizontalOffset,
			verticalOffset;

            if (pos.length === 1) {
                pos = rhorizontal.test(pos[0]) ?
				pos.concat(["center"]) :
				rvertical.test(pos[0]) ?
					["center"].concat(pos) :
					["center", "center"];
            }
            pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
            pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

            // calculate offsets
            horizontalOffset = roffset.exec(pos[0]);
            verticalOffset = roffset.exec(pos[1]);
            offsets[this] = [
			horizontalOffset ? horizontalOffset[0] : 0,
			verticalOffset ? verticalOffset[0] : 0
		];

            // reduce to just the positions without the offsets
            options[this] = [
			rposition.exec(pos[0])[0],
			rposition.exec(pos[1])[0]
		];
        });

        // normalize collision option
        if (collision.length === 1) {
            collision[1] = collision[0];
        }

        if (options.at[0] === "right") {
            basePosition.left += targetWidth;
        } else if (options.at[0] === "center") {
            basePosition.left += targetWidth / 2;
        }

        if (options.at[1] === "bottom") {
            basePosition.top += targetHeight;
        } else if (options.at[1] === "center") {
            basePosition.top += targetHeight / 2;
        }

        atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
        basePosition.left += atOffset[0];
        basePosition.top += atOffset[1];

        return this.each(function () {
            var collisionPosition, using,
			elem = $(this),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss(this, "marginLeft"),
			marginTop = parseCss(this, "marginTop"),
			collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
			position = $.extend({}, basePosition),
			myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

            if (options.my[0] === "right") {
                position.left -= elemWidth;
            } else if (options.my[0] === "center") {
                position.left -= elemWidth / 2;
            }

            if (options.my[1] === "bottom") {
                position.top -= elemHeight;
            } else if (options.my[1] === "center") {
                position.top -= elemHeight / 2;
            }

            position.left += myOffset[0];
            position.top += myOffset[1];

            // if the browser doesn't support fractions, then round for consistent results
            if (!$.support.offsetFractions) {
                position.left = round(position.left);
                position.top = round(position.top);
            }

            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };

            $.each(["left", "top"], function (i, dir) {
                if ($.ui.position[collision[i]]) {
                    $.ui.position[collision[i]][dir](position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    });
                }
            });

            if ($.fn.bgiframe) {
                elem.bgiframe();
            }

            if (options.using) {
                // adds feedback as second argument to using callback, if present
                using = function (props) {
                    var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
					    target: {
					        element: target,
					        left: targetOffset.left,
					        top: targetOffset.top,
					        width: targetWidth,
					        height: targetHeight
					    },
					    element: {
					        element: elem,
					        left: position.left,
					        top: position.top,
					        width: elemWidth,
					        height: elemHeight
					    },
					    horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
					    vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
                    if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                        feedback.horizontal = "center";
                    }
                    if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                        feedback.vertical = "middle";
                    }
                    if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call(this, props, feedback);
                };
            }

            elem.offset($.extend(position, { using: using }));
        });
    };

    $.ui.position = {
        fit: {
            left: function (position, data) {
                var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

                // element is wider than within
                if (data.collisionWidth > outerWidth) {
                    // element is initially over the left side of within
                    if (overLeft > 0 && overRight <= 0) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                        position.left += overLeft - newOverRight;
                        // element is initially over right side of within
                    } else if (overRight > 0 && overLeft <= 0) {
                        position.left = withinOffset;
                        // element is initially over both left and right sides of within
                    } else {
                        if (overLeft > overRight) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }
                    // too far left -> align with left edge
                } else if (overLeft > 0) {
                    position.left += overLeft;
                    // too far right -> align with right edge
                } else if (overRight > 0) {
                    position.left -= overRight;
                    // adjust based on position and margin
                } else {
                    position.left = max(position.left - collisionPosLeft, position.left);
                }
            },
            top: function (position, data) {
                var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

                // element is taller than within
                if (data.collisionHeight > outerHeight) {
                    // element is initially over the top of within
                    if (overTop > 0 && overBottom <= 0) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                        position.top += overTop - newOverBottom;
                        // element is initially over bottom of within
                    } else if (overBottom > 0 && overTop <= 0) {
                        position.top = withinOffset;
                        // element is initially over both top and bottom of within
                    } else {
                        if (overTop > overBottom) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }
                    // too far up -> align with top
                } else if (overTop > 0) {
                    position.top += overTop;
                    // too far down -> align with bottom edge
                } else if (overBottom > 0) {
                    position.top -= overBottom;
                    // adjust based on position and margin
                } else {
                    position.top = max(position.top - collisionPosTop, position.top);
                }
            }
        },
        flip: {
            left: function (position, data) {
                var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[0] === "left" ?
					-data.elemWidth :
					data.my[0] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[0] === "left" ?
					data.targetWidth :
					data.at[0] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[0],
				newOverRight,
				newOverLeft;

                if (overLeft < 0) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                    if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
                else if (overRight > 0) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                    if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function (position, data) {
                var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[1] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[1] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[1] === "top" ?
					data.targetHeight :
					data.at[1] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[1],
				newOverTop,
				newOverBottom;
                if (overTop < 0) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                    if ((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
                else if (overBottom > 0) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                    if ((position.top + myOffset + atOffset + offset) > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function () {
                $.ui.position.flip.left.apply(this, arguments);
                $.ui.position.fit.left.apply(this, arguments);
            },
            top: function () {
                $.ui.position.flip.top.apply(this, arguments);
                $.ui.position.fit.top.apply(this, arguments);
            }
        }
    };

    // fraction support test
    (function () {
        var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName("body")[0],
		div = document.createElement("div");

        //Create a "fake body" for testing based on method used in jQuery.support
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        };
        if (body) {
            $.extend(testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || document.documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);

        div.style.cssText = "position: absolute; left: 10.7432222px;";

        offsetLeft = $(div).offset().left;
        $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);
    })();

    // DEPRECATED
    if ($.uiBackCompat !== false) {
        // offset option
        (function ($) {
            var _position = $.fn.position;
            $.fn.position = function (options) {
                if (!options || !options.offset) {
                    return _position.call(this, options);
                }
                var offset = options.offset.split(" "),
				at = options.at.split(" ");
                if (offset.length === 1) {
                    offset[1] = offset[0];
                }
                if (/^\d/.test(offset[0])) {
                    offset[0] = "+" + offset[0];
                }
                if (/^\d/.test(offset[1])) {
                    offset[1] = "+" + offset[1];
                }
                if (at.length === 1) {
                    if (/left|center|right/.test(at[0])) {
                        at[1] = "center";
                    } else {
                        at[1] = at[0];
                        at[0] = "center";
                    }
                }
                return _position.call(this, $.extend(options, {
                    at: at[0] + offset[0] + " " + at[1] + offset[1],
                    offset: undefined
                }));
            };
        } (jQuery));
    }

} (jQuery));
(function ($, undefined) {

    // used to prevent race conditions with remote data sources
    var requestIndex = 0;

    $.widget("ui.autocomplete", {
        version: "1.9.2",
        defaultElement: "<input>",
        options: {
            appendTo: "body",
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,

            // callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },

        pending: 0,

        _create: function () {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

            this.isMultiLine = this._isMultiLine();
            this.valueMethod = this.element[this.element.is("input,textarea") ? "val" : "text"];
            this.isNewMenu = true;

            this.element
			.addClass("ui-autocomplete-input")
			.attr("autocomplete", "off");

            this._on(this.element, {
                keydown: function (event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }

                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            // when menu is open and has focus
                            if (this.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                this._value(this.term);
                                this.close(event);
                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;
                        default:
                            suppressKeyPressRepeat = true;
                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                    }
                },
                keypress: function (event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        event.preventDefault();
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }

                    // replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                    }
                },
                input: function (event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function () {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function (event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }

                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });

            this._initSource();
            this.menu = $("<ul>")
			.addClass("ui-autocomplete")
			.appendTo(this.document.find(this.options.appendTo || "body")[0])
			.menu({
			    // custom key handling for now
			    input: $(),
			    // disable ARIA support, the live region takes care of that
			    role: null
			})
			.zIndex(this.element.zIndex() + 1)
			.hide()
			.data("menu");

            this._on(this.menu.element, {
                mousedown: function (event) {
                    // prevent moving focus out of the text field
                    event.preventDefault();

                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = true;
                    this._delay(function () {
                        delete this.cancelBlur;
                    });

                    // clicking on the scrollbar causes focus to shift to the body
                    // but we can't detect a mouseup or a click immediately afterward
                    // so we have to track the next mousedown and close the menu if
                    // the user clicks somewhere outside of the autocomplete
                    var menuElement = this.menu.element[0];
                    if (!$(event.target).closest(".ui-menu-item").length) {
                        this._delay(function () {
                            var that = this;
                            this.document.one("mousedown", function (event) {
                                if (event.target !== that.element[0] &&
									event.target !== menuElement &&
									!$.contains(menuElement, event.target)) {
                                    that.close();
                                }
                            });
                        });
                    }
                },
                menufocus: function (event, ui) {
                    // #7024 - Prevent accidental activation of menu items in Firefox
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();

                            this.document.one("mousemove", function () {
                                $(event.target).trigger(event.originalEvent);
                            });

                            return;
                        }
                    }

                    // back compat for _renderItem using item.autocomplete, via #7810
                    // TODO remove the fallback, see #8156
                    var item = ui.item.data("ui-autocomplete-item") || ui.item.data("item.autocomplete");
                    if (false !== this._trigger("focus", event, { item: item })) {
                        // use value to match what will end up in the input, if it was a key event
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    } else {
                        // Normally the input is populated with the item's value as the
                        // menu is navigated, causing screen readers to notice a change and
                        // announce the item. Since the focus event was canceled, this doesn't
                        // happen, so we update the live region so that screen readers can
                        // still notice the change and announce it.
                        this.liveRegion.text(item.value);
                    }
                },
                menuselect: function (event, ui) {
                    // back compat for _renderItem using item.autocomplete, via #7810
                    // TODO remove the fallback, see #8156
                    var item = ui.item.data("ui-autocomplete-item") || ui.item.data("item.autocomplete"),
					previous = this.previous;

                    // only trigger when focus was lost (click on menu)
                    if (this.element[0] !== this.document[0].activeElement) {
                        this.element.focus();
                        this.previous = previous;
                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay(function () {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }

                    if (false !== this._trigger("select", event, { item: item })) {
                        this._value(item.value);
                    }
                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();

                    this.close(event);
                    this.selectedItem = item;
                }
            });

            this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "polite"
            })
			.addClass("ui-helper-hidden-accessible")
			.insertAfter(this.element);

            if ($.fn.bgiframe) {
                this.menu.element.bgiframe();
            }

            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _destroy: function () {
            clearTimeout(this.searching);
            this.element
			.removeClass("ui-autocomplete-input")
			.removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this.document.find(value || "body")[0]);
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _isMultiLine: function () {
            // Textareas are always multi-line
            if (this.element.is("textarea")) {
                return true;
            }
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            if (this.element.is("input")) {
                return false;
            }
            // All other element types are determined by whether or not they're contentEditable
            return this.element.prop("isContentEditable");
        },

        _initSource: function () {
            var array, url,
			that = this;
            if ($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function (request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function (request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function (data) {
                            response(data);
                        },
                        error: function () {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },

        _searchTimeout: function (event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function () {
                // only search if the value has changed
                if (this.term !== this._value()) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },

        search: function (value, event) {
            value = value != null ? value : this._value();

            // always save the actual value, not the one passed as an argument
            this.term = this._value();

            if (value.length < this.options.minLength) {
                return this.close(event);
            }

            if (this._trigger("search", event) === false) {
                return;
            }

            return this._search(value);
        },

        _search: function (value) {
            this.pending++;
            this.element.addClass("ui-autocomplete-loading");
            this.cancelSearch = false;

            this.source({ term: value }, this._response());
        },

        _response: function () {
            var that = this,
			index = ++requestIndex;

            return function (content) {
                if (index === requestIndex) {
                    that.__response(content);
                }

                that.pending--;
                if (!that.pending) {
                    that.element.removeClass("ui-autocomplete-loading");
                }
            };
        },

        __response: function (content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, { content: content });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },

        close: function (event) {
            this.cancelSearch = true;
            this._close(event);
        },

        _close: function (event) {
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },

        _change: function (event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, { item: this.selectedItem });
            }
        },

        _normalize: function (items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function (item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({
                    label: item.label || item.value,
                    value: item.value || item.label
                }, item);
            });
        },

        _suggest: function (items) {
            var ul = this.menu.element
			.empty()
			.zIndex(this.element.zIndex() + 1);
            this._renderMenu(ul, items);
            this.menu.refresh();

            // size and position menu
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));

            if (this.options.autoFocus) {
                this.menu.next();
            }
        },

        _resizeMenu: function () {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(
            // Firefox wraps long text (possibly a rounding bug)
            // so we add 1px to avoid the wrapping (#7513)
			ul.width("").outerWidth() + 1,
			this.element.outerWidth()
		));
        },

        _renderMenu: function (ul, items) {
            var that = this;
            $.each(items, function (index, item) {
                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function (ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },

        _renderItem: function (ul, item) {
            return $("<li>")
			.append($("<a>").text(item.label))
			.appendTo(ul);
        },

        _move: function (direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) ||
				this.menu.isLastItem() && /^next/.test(direction)) {
                this._value(this.term);
                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },

        widget: function () {
            return this.menu.element;
        },

        _value: function () {
            return this.valueMethod.apply(this.element, arguments);
        },

        _keyEvent: function (keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);

                // prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        }
    });

    $.extend($.ui.autocomplete, {
        escapeRegex: function (value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function (array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function (value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });


    // live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function (amount) {
                    return amount + (amount > 1 ? " results are" : " result is") +
					" available, use up and down arrow keys to navigate.";
                }
            }
        },

        __response: function (content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.text(message);
        }
    });


} (jQuery));
(function ($, undefined) {

    var mouseHandled = false;

    $.widget("ui.menu", {
        version: "1.9.2",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            menus: "ul",
            position: {
                my: "left top",
                at: "right top"
            },
            role: "menu",

            // callbacks
            blur: null,
            focus: null,
            select: null
        },

        _create: function () {
            this.activeMenu = this.element;
            this.element
			.uniqueId()
			.addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
			.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length)
			.attr({
			    role: this.options.role,
			    tabIndex: 0
			})
            // need to catch all clicks on disabled menu
            // not possible through _on
			.bind("click" + this.eventNamespace, $.proxy(function (event) {
			    if (this.options.disabled) {
			        event.preventDefault();
			    }
			}, this));

            if (this.options.disabled) {
                this.element
				.addClass("ui-state-disabled")
				.attr("aria-disabled", "true");
            }

            this._on({
                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item > a": function (event) {
                    event.preventDefault();
                },
                "click .ui-state-disabled > a": function (event) {
                    event.preventDefault();
                },
                "click .ui-menu-item:has(a)": function (event) {
                    var target = $(event.target).closest(".ui-menu-item");
                    if (!mouseHandled && target.not(".ui-state-disabled").length) {
                        mouseHandled = true;

                        this.select(event);
                        // Open submenu on click
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus")) {
                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function (event) {
                    var target = $(event.currentTarget);
                    // Remove ui-state-active class from siblings of the newly focused menu item
                    // to avoid a jump caused by adjacent elements both having a class with a border
                    target.siblings().children(".ui-state-active").removeClass("ui-state-active");
                    //this.focus( event, target );
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function (event, keepActiveItem) {
                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this.element.children(".ui-menu-item").eq(0);

                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function (event) {
                    this._delay(function () {
                        if (!$.contains(this.element[0], this.document[0].activeElement)) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });

            this.refresh();

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
                click: function (event) {
                    if (!$(event.target).closest(".ui-menu").length) {
                        this.collapseAll(event);
                    }

                    // Reset the mouseHandled flag
                    mouseHandled = false;
                }
            });
        },

        _destroy: function () {
            // Destroy (sub)menus
            this.element
			.removeAttr("aria-activedescendant")
			.find(".ui-menu").andSelf()
				.removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons")
				.removeAttr("role")
				.removeAttr("tabIndex")
				.removeAttr("aria-labelledby")
				.removeAttr("aria-expanded")
				.removeAttr("aria-hidden")
				.removeAttr("aria-disabled")
				.removeUniqueId()
				.show();

            // Destroy menu items
            this.element.find(".ui-menu-item")
			.removeClass("ui-menu-item")
			.removeAttr("role")
			.removeAttr("aria-disabled")
			.children("a")
				.removeUniqueId()
				.removeClass("ui-corner-all ui-state-hover")
				.removeAttr("tabIndex")
				.removeAttr("role")
				.removeAttr("aria-haspopup")
				.children().each(function () {
				    var elem = $(this);
				    if (elem.data("ui-menu-submenu-carat")) {
				        elem.remove();
				    }
				});

            // Destroy menu dividers
            this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },

        _keydown: function (event) {
            var match, prev, character, skip, regex,
			preventDefault = true;

            function escape(value) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            }

            switch (event.keyCode) {
                case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;
                case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;
                case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;
                case $.ui.keyCode.UP:
                    this.previous(event);
                    break;
                case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;
                case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;
                case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;
                case $.ui.keyCode.ENTER:
                case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;
                case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;
                default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    character = String.fromCharCode(event.keyCode);
                    skip = false;

                    clearTimeout(this.filterTimer);

                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }

                    regex = new RegExp("^" + escape(character), "i");
                    match = this.activeMenu.children(".ui-menu-item").filter(function () {
                        return regex.test($(this).children("a").text());
                    });
                    match = skip && match.index(this.active.next()) !== -1 ?
				this.active.nextAll(".ui-menu-item") :
				match;

                    // If no matches on the current filter, reset to the last character pressed
                    // to move down the menu to the first item that starts with that character
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        regex = new RegExp("^" + escape(character), "i");
                        match = this.activeMenu.children(".ui-menu-item").filter(function () {
                            return regex.test($(this).children("a").text());
                        });
                    }

                    if (match.length) {
                        this.focus(event, match);
                        if (match.length > 1) {
                            this.previousFilter = character;
                            this.filterTimer = this._delay(function () {
                                delete this.previousFilter;
                            }, 1000);
                        } else {
                            delete this.previousFilter;
                        }
                    } else {
                        delete this.previousFilter;
                    }
            }

            if (preventDefault) {
                event.preventDefault();
            }
        },

        _activate: function (event) {
            if (!this.active.is(".ui-state-disabled")) {
                if (this.active.children("a[aria-haspopup='true']").length) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },

        refresh: function () {
            var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find(this.options.menus);

            // Initialize nested menus
            submenus.filter(":not(.ui-menu)")
			.addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
			.hide()
			.attr({
			    role: this.options.role,
			    "aria-hidden": "true",
			    "aria-expanded": "false"
			})
			.each(function () {
			    var menu = $(this),
					item = menu.prev("a"),
					submenuCarat = $("<span>")
						.addClass("ui-menu-icon ui-icon " + icon)
						.data("ui-menu-submenu-carat", true);

			    item
					.attr("aria-haspopup", "true")
					.prepend(submenuCarat);
			    menu.attr("aria-labelledby", item.attr("id"));
			});

            menus = submenus.add(this.element);

            // Don't refresh list items that are already adapted
            menus.children(":not(.ui-menu-item):has(a)")
			.addClass("ui-menu-item")
			.attr("role", "presentation")
			.children("a")
				.uniqueId()
				.addClass("ui-corner-all")
				.attr({
				    tabIndex: -1,
				    role: this._itemRole()
				});

            // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
            menus.children(":not(.ui-menu-item)").each(function () {
                var item = $(this);
                // hyphen, em dash, en dash
                if (!/[^\-—–\s]/.test(item.text())) {
                    item.addClass("ui-widget-content ui-menu-divider");
                }
            });

            // Add aria-disabled attribute to any disabled menu item
            menus.children(".ui-state-disabled").attr("aria-disabled", "true");

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },

        _itemRole: function () {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },

        focus: function (event, item) {
            var nested, focused;
            this.blur(event, event && event.type === "focus");

            this._scrollIntoView(item);

            this.active = item.first();
            focused = this.active.children("a").addClass("ui-state-focus");
            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }

            // Highlight active parent menu item, if any
            this.active
			.parent()
			.closest(".ui-menu-item")
			.children("a:first")
			.addClass("ui-state-active");

            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function () {
                    this._close();
                }, this.delay);
            }

            nested = item.children(".ui-menu");
            if (nested.length && (/^mouse/.test(event.type))) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();

            this._trigger("focus", event, { item: item });
        },

        _scrollIntoView: function (item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.height();

                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },

        blur: function (event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }

            if (!this.active) {
                return;
            }

            this.active.children("a").removeClass("ui-state-focus");
            this.active = null;

            this._trigger("blur", event, { item: this.active });
        },

        _startOpening: function (submenu) {
            clearTimeout(this.timer);

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the carat icon
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }

            this.timer = this._delay(function () {
                this._close();
                this._open(submenu);
            }, this.delay);
        },

        _open: function (submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);

            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
			.hide()
			.attr("aria-hidden", "true");

            submenu
			.show()
			.removeAttr("aria-hidden")
			.attr("aria-expanded", "true")
			.position(position);
        },

        collapseAll: function (event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function () {
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all ? this.element :
				$(event && event.target).closest(this.element.find(".ui-menu"));

                // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }

                this._close(currentMenu);

                this.blur(event);
                this.activeMenu = currentMenu;
            }, this.delay);
        },

        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function (startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }

            startMenu
			.find(".ui-menu")
				.hide()
				.attr("aria-hidden", "true")
				.attr("aria-expanded", "false")
			.end()
			.find("a.ui-state-active")
				.removeClass("ui-state-active");
        },

        collapse: function (event) {
            var newItem = this.active &&
			this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },

        expand: function (event) {
            var newItem = this.active &&
			this.active
				.children(".ui-menu ")
				.children(".ui-menu-item")
				.first();

            if (newItem && newItem.length) {
                this._open(newItem.parent());

                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                this._delay(function () {
                    this.focus(event, newItem);
                });
            }
        },

        next: function (event) {
            this._move("next", "first", event);
        },

        previous: function (event) {
            this._move("prev", "last", event);
        },

        isFirstItem: function () {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },

        isLastItem: function () {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },

        _move: function (direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active
					[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item")
					.eq(-1);
                } else {
                    next = this.active
					[direction + "All"](".ui-menu-item")
					.eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.children(".ui-menu-item")[filter]();
            }

            this.focus(event, next);
        },

        nextPage: function (event) {
            var item, base, height;

            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.children(".ui-menu-item")
				[!this.active ? "first" : "last"]());
            }
        },

        previousPage: function (event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.children(".ui-menu-item").first());
            }
        },

        _hasScroll: function () {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },

        select: function (event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = { item: this.active };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        }
    });

} (jQuery));







$(document).ready(function () {
    /* EasyAsk Autocomplete Init */
    (function (jQuery) {
        (function ($, undefined) {
            $(function () {

                /*function navObject() {
                var n = {
                size: 3,
                sections: [
                { size: 5, title: 'Category', type: 'Category' },
                { size: 4, title: 'Manufacturer', type: 'Manufacturer' },
                { size: 20, title: 'Price', type: 'Price Range' }
                ]
                }

                if(window.innerWidth > 991) {
                n.size = 3;
                n.sections.push({ size: 5, title: 'Category', type: 'Category' });
                n.sections.push({ size: 4, title: 'Manufacturer', type: 'Manufacturer' });
                n.sections.push({ size: 20, title: 'Price', type: 'Price Range' });
                };

                console.log(n);
                return n;
                }*/


                function fixedWidth(large) {
                    if (large) return 600;
                    return 550;
                }

                function horizAlign(large) {
                    if (large) return 'right';
                    return 'center';
                }

                function leftWidth(large) {
                    if (large) return '63%';
                    return undefined;
                }

                var large = window.innerWidth > 991 ? true : false;

                var acOptions = {
                    serverSearch: 'http://192.168.20.6:9200/EasyAsk',
                    fixedWidth: fixedWidth(large),
                    horizAlign: horizAlign(large),
                    leftWidth: leftWidth(large),
                    url: 'http://192.168.20.6:9200/EasyAsk/AutoComplete-1.2.1.jsp',
                    dict: 'webcat',
                    id: 'easyAsk',
                    prompt: 'Search products...',
                    search: {
                        heading: { display: false }
                    },
                    submitFctn: function (type, val) {
                        //$('#quickSearchForm .icon-search').click();
                       
                        if (type == 'nav') {
                            var search = val;
                            var parts = search.split("/");

                            $('#easyAsk').val(decodeURIComponent(parts[0]).replace(/-/g, " ")
															.replace(/&amp;/g, '&'));
                            if (parts.length > 1) {
                                $('#attributes').val(parts[1].replace("-P-A", " P.A.").replace(/-/g, " "));
                            }
                            $('#quickSearchForm').submit();
                        }
                        else if (type == 'nav_cat') {
                            var search = val;
                            var parts = search.split("/");

                            $('#easyAsk').val(decodeURIComponent(parts[0]).replace(/-/g, " ")
															.replace(/&amp;/g, '&'));
                            if (parts.length > 1) {
                                $('#attributes').val(parts[2].replace("-P-A", " P.A.").replace(/-/g, " "));
                            }
                            $('#quickSearchForm').submit();
                        }
                        else {
                            $('#btnSearch').click();
                        }
                    },
                    products: {
                        fields: {
                            thumbnail: 'Thumbnail',
                            name: 'Product_Name',
                            description: 'Short_Description',
                            price: 'Price'
                        },
                        sizes: {
                            description: 60
                        },
                        value: function (item, field) {
                            if (field == 'link') {
                                var link = '/' + clean(item['Category_Name']) + '/pid' + item['Product_Id'] + '/cid' + item['Category_ID'] + '/' + clean(item['Product_Name']);
                                //alert("link " + link);
                                return link;
                            }

                            else if (field == 'Thumbnail') {
                                var thumbnail = item['Thumbnail'];
                                return thumbnail.replace("http://", "//").replace("/catalog/i/m_", "/catalog/i/s_");
                            }

                            else {
                                var itemField = item[field];
                                //alert("itemField " + itemField);
                                return itemField;
                            }
                        }
                    },
                    navigation: {
                        size: 3,
                        sections: [
								{ size: 5, title: 'Category', type: 'Category' },
								{ size: 4, title: 'Manufacturer', type: 'Manufacturer' },
								{ size: 20, title: 'Price', type: 'Price Range' }
							]
                    }
                };

                new EAAutoComplete().init(acOptions);

            });
        } (jQuery));
    } (window.eaj$183 || jQuery));
});
